plugins {
  id 'com.android.application' version '8.6.0'
  id 'org.jetbrains.kotlin.android' version '1.9.20'
}

dependencies {
  implementation "androidx.window:window-java:1.3.0"
  implementation "androidx.core:core:1.15.0"  // Downgraded from 1.16.0 (requires SDK 35)
  implementation "androidx.appcompat:appcompat:1.6.1"
  implementation "androidx.multidex:multidex:2.0.1"
  implementation "com.google.android.material:material:1.11.0"
  implementation "androidx.viewpager2:viewpager2:1.0.0"
  implementation "androidx.recyclerview:recyclerview:1.3.2"
  implementation "androidx.preference:preference-ktx:1.2.1"

  // Kotlin dependencies
  implementation "org.jetbrains.kotlin:kotlin-stdlib:1.9.20"
  implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3"

  // Jetpack Compose dependencies (for settings UI)
  implementation "androidx.activity:activity-compose:1.8.2"
  implementation "androidx.compose.ui:ui:1.5.4"
  implementation "androidx.compose.ui:ui-tooling-preview:1.5.4"
  implementation "androidx.compose.material3:material3:1.1.2"
  implementation "androidx.compose.foundation:foundation:1.5.4"

  // Lifecycle dependencies for Compose in InputMethodService (Fix ViewTreeLifecycleOwner crash)
  implementation "androidx.lifecycle:lifecycle-runtime-ktx:2.6.2"
  implementation "androidx.savedstate:savedstate-ktx:1.2.1"

  // Reorderable for drag-and-drop in Layout Manager
  implementation "org.burnoutcrew.composereorderable:reorderable:0.9.6"

  // ONNX Runtime for neural swipe prediction (upgraded for boolean tensor support)
  implementation "com.microsoft.onnxruntime:onnxruntime-android:1.20.0"

  // Gson for JSON serialization/deserialization (backup/restore functionality)
  implementation "com.google.code.gson:gson:2.10.1"

  testImplementation "junit:junit:4.13.2"
  testImplementation "org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3"
  testImplementation "org.robolectric:robolectric:4.11.1"
  testImplementation "androidx.test:core:1.5.0"

  // Android instrumentation test dependencies
  androidTestImplementation "androidx.test.ext:junit:1.1.5"
  androidTestImplementation "androidx.test:runner:1.5.2"
  androidTestImplementation "androidx.test:rules:1.5.0"
  androidTestImplementation "org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3"
}

// Version management functions
def getVersionCode() {
    try {
        def code = 'git rev-list --count HEAD'.execute().text.trim().toInteger()
        println "ðŸš€ CleverKeys version code (git): ${code}"
        return code
    } catch (ignored) {
        println "âš ï¸ Git not found, using default version code"
        return 1
    }
}

def getVersionName() {
    try {
        def count = 'git rev-list --count HEAD'.execute().text.trim()
        def shortSha = 'git rev-parse --short HEAD'.execute().text.trim()
        return "1.1.${count}-${shortSha}"
    } catch (ignored) {
        return "1.1.0-dev"
    }
}

android {
  namespace 'tribixbite.cleverkeys'
  compileSdk 34  // Lowered from 35 for F-Droid androguard compatibility

  defaultConfig {
    applicationId "tribixbite.cleverkeys"
    minSdk 21
    targetSdkVersion 34  // Lowered from 35 for F-Droid androguard compatibility
    versionCode getVersionCode()
    versionName getVersionName()
    testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    multiDexEnabled true
  }

  // ABI splits disabled for F-Droid compatibility
  // The universal APK (~75MB) includes ONNX runtime for all architectures
  // splits {
  //   abi {
  //     enable true
  //     reset()
  //     include 'x86_64', 'armeabi-v7a', 'arm64-v8a'
  //     universalApk true
  //   }
  // }

  compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
  }

  kotlinOptions {
    jvmTarget = "1.8"
  }

  buildFeatures {
    compose true
  }

  composeOptions {
    kotlinCompilerExtensionVersion = '1.5.4'
  }

  sourceSets {
    main {
      manifest.srcFile 'AndroidManifest.xml'
      kotlin.srcDirs = ['src/main/kotlin']
      java.srcDirs = ['src/main/java']
      res.srcDirs = ['res', 'build/generated-resources']
      assets.srcDirs = ['assets', 'src/main/assets']
    }

    test {
      kotlin.srcDirs = ['src/test/kotlin']
      java.srcDirs = ['src/test/java']
    }

    androidTest {
      kotlin.srcDirs = ['src/androidTest/kotlin']
    }
  }

  signingConfigs {
    // Debug builds will always be signed. If no environment variables are set, a default
    // keystore will be initialized by the task initDebugKeystore and used. This keystore
    // can be uploaded to GitHub secrets by following instructions in CONTRIBUTING.md
    // in order to always receive correctly signed debug APKs from the CI.
    debug {
      storeFile(System.env.DEBUG_KEYSTORE ? file(System.env.DEBUG_KEYSTORE) : file("debug.keystore"))
      storePassword(System.env.DEBUG_KEYSTORE_PASSWORD ? "$System.env.DEBUG_KEYSTORE_PASSWORD" : "debug0")
      keyAlias(System.env.DEBUG_KEY_ALIAS ? "$System.env.DEBUG_KEY_ALIAS" : "debug")
      keyPassword(System.env.DEBUG_KEY_PASSWORD ? "$System.env.DEBUG_KEY_PASSWORD" : "debug0")
    }

    release {
      if (System.env.RELEASE_KEYSTORE) {
        storeFile file(System.env.RELEASE_KEYSTORE)
        storePassword "$System.env.RELEASE_KEYSTORE_PASSWORD"
        keyAlias "$System.env.RELEASE_KEY_ALIAS"
        keyPassword "$System.env.RELEASE_KEY_PASSWORD"
      }
    }
  }

  buildTypes {
    release {
      minifyEnabled true
      shrinkResources true
      debuggable false
      proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
      resValue "string", "app_name", "@string/app_name_release"
      signingConfig signingConfigs.release
    }

    debug {
      // FIX: Removed applicationIdSuffix ".debug" to fix keyboard service crash
      // The .debug suffix prevented Android from properly binding InputMethodService
      minifyEnabled false
      shrinkResources false
      debuggable true
      // applicationIdSuffix ".debug"  // DO NOT ADD THIS BACK - it breaks IME binding!
      resValue "string", "app_name", "@string/app_name_debug"
      resValue "bool", "debug_logs", "true"
      signingConfig signingConfigs.debug
    }
  }

  // Name outputs with application ID (no ABI suffix since splits are disabled)
  android.applicationVariants.all { variant ->
    variant.outputs.all { output ->
      outputFileName = "${applicationId}-release.apk"
    }
  }

  compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
  }

  lint {
    baseline = file("lint-baseline.xml")
    abortOnError = false
    checkReleaseBuilds = false
  }

  testOptions {
    unitTests {
      includeAndroidResources = true
      returnDefaultValues = true
    }
  }
}

// Skip Robolectric tests on ARM64 (no Conscrypt native libraries available)
def isArm64 = System.getProperty("os.arch") in ["aarch64", "arm64"]
if (isArm64) {
  tasks.withType(Test).configureEach {
    enabled = false
    println "âš ï¸ Skipping unit tests on ARM64 architecture (Robolectric requires x86_64)"
  }
}

tasks.register('buildKeyboardFont') {
  // Skip font building if font already exists
  def fontFile = file("assets/special_font.ttf")
  if (fontFile.exists()) {
    println "\nSpecial font already exists, skipping build"
    return
  }

  println "\nBuilding assets/special_font.ttf"
  mkdir "$buildDir"
  exec {
    workingDir "$projectDir/srcs/special_font"
    def svgFiles = workingDir.listFiles().findAll {
      it.isFile() && it.name.endsWith(".svg")
    }
    commandLine("fontforge", "-lang=ff", "-script", "build.pe", "$buildDir/special_font.ttf", *svgFiles)
  }
  copy {
    from "$buildDir/special_font.ttf"
    into "assets"
  }
}

tasks.register('genEmojis') {
  def outFile = file("res/raw/emojis.txt")
  // Skip if output already exists
  if (outFile.exists() && outFile.length() > 1000) {
    println "\nEmojis.txt already exists, skipping generation"
    return
  }
  println "\nGenerating res/raw/emojis.txt"
  exec {
    workingDir = projectDir
    commandLine "python3", "gen_emoji.py"
    ignoreExitValue = true  // Don't fail CI if python script unavailable
  }
}

tasks.withType(Test).configureEach {
  dependsOn 'genLayoutsList'
  dependsOn 'checkKeyboardLayouts'
  dependsOn 'generateComposeData'
}

tasks.register('genLayoutsList') {
  def outFile = file("res/values/layouts.xml")
  // Skip if output already exists
  if (outFile.exists() && outFile.length() > 100) {
    println "\nLayouts.xml already exists, skipping generation"
    return
  }
  println "\nGenerating res/values/layouts.xml"
  exec {
    workingDir = projectDir
    commandLine "python3", "gen_layouts.py"
    ignoreExitValue = true  // Don't fail CI if python script unavailable
  }
}

tasks.register('checkKeyboardLayouts') {
  // Skip layout check on CI (python dependencies may not be available)
  def genLayoutsFile = file("res/values/layouts.xml")
  if (!genLayoutsFile.exists()) {
    println "\nâš ï¸ Skipping layout check - layouts.xml not found"
    return
  }
  println "\nChecking layouts"
  exec {
    workingDir = projectDir
    commandLine("python3", "tools/check_layout.py")
    ignoreExitValue = true  // Don't fail CI if check script fails
  }
}

// compileComposeSequences removed - use generateComposeData instead

tasks.register('generateBinaryDictionaries') {
  description 'Generate optimized binary dictionaries from JSON sources'
  doLast {
    def dictDir = file("src/main/assets/dictionaries")
    def jsonFiles = dictDir.listFiles().findAll { it.name.endsWith(".json") && !it.name.contains("contraction") }

    jsonFiles.each { jsonFile ->
      def binFile = new File(dictDir, jsonFile.name.replace(".json", ".bin"))

      // Only regenerate if JSON is newer than binary, or binary doesn't exist
      if (!binFile.exists() || jsonFile.lastModified() > binFile.lastModified()) {
        println "Generating binary dictionary: ${binFile.name}"
        exec {
          workingDir = projectDir
          commandLine "python3", "scripts/generate_binary_dict.py", jsonFile.absolutePath, binFile.absolutePath
        }
      } else {
        println "Binary dictionary up-to-date: ${binFile.name}"
      }
    }
  }
}

tasks.register('generateBinaryContractions') {
  description 'Generate optimized binary contractions from JSON sources'
  doLast {
    def dictDir = file("src/main/assets/dictionaries")
    def nonPairedFile = new File(dictDir, "contractions_non_paired.json")
    def pairedFile = new File(dictDir, "contraction_pairings.json")
    def binFile = new File(dictDir, "contractions.bin")

    // Only regenerate if either JSON is newer than binary, or binary doesn't exist
    def needsRegenerate = !binFile.exists() ||
                          nonPairedFile.lastModified() > binFile.lastModified() ||
                          pairedFile.lastModified() > binFile.lastModified()

    if (needsRegenerate) {
      println "Generating binary contractions: ${binFile.name}"
      exec {
        workingDir = projectDir
        commandLine "python3", "scripts/generate_binary_contractions.py",
                    nonPairedFile.absolutePath,
                    pairedFile.absolutePath,
                    binFile.absolutePath
      }
    } else {
      println "Binary contractions up-to-date: ${binFile.name}"
    }
  }
}

tasks.register('generateVersionInfo') {
  doLast {
    def gitCommit = 'git rev-parse --short HEAD'.execute().text.trim()
    def gitCommitFull = 'git rev-parse HEAD'.execute().text.trim()
    def gitDate = 'git log -1 --format=%cd --date=short'.execute().text.trim()
    def buildDate = new Date().format('yyyy-MM-dd HH:mm:ss')
    def buildNumber = System.currentTimeMillis().toString()

    def versionFile = file("build/generated-resources/raw/version_info.txt")
    versionFile.parentFile.mkdirs()
    versionFile.text = """commit=$gitCommit
commit_full=$gitCommitFull
commit_date=$gitDate
build_date=$buildDate
build_number=$buildNumber
"""

    println "Generated version info: $gitCommit ($gitDate)"
  }
}

tasks.named("preBuild") {
  dependsOn += "initDebugKeystore"
  dependsOn += "copyRawQwertyUS"
  dependsOn += "copyLayoutDefinitions"
  dependsOn += "generateBinaryDictionaries"
  dependsOn += "generateBinaryContractions"
  dependsOn += "generateComposeData"
  dependsOn += "generateVersionInfo"
}

tasks.register('generateComposeData') {
  description 'Generate compose_data.bin from compose sequence sources'
  doLast {
    def composeDir = file("srcs/compose")
    def outputBin = file("src/main/assets/compose_data.bin")
    def outputKt = file("src/main/kotlin/tribixbite/cleverkeys/ComposeKeyData.kt")

    // Skip if output exists and is newer than all sources
    def sourceFiles = composeDir.listFiles().findAll {
      it.name.endsWith(".json") || it.isDirectory()
    }
    def latestSource = sourceFiles.collect {
      it.isDirectory() ? it.listFiles()?.collect { f -> f.lastModified() }?.max() ?: 0 : it.lastModified()
    }.max() ?: 0

    if (outputBin.exists() && outputKt.exists() &&
        outputBin.lastModified() > latestSource &&
        outputKt.lastModified() > latestSource) {
      println "\nCompose data up-to-date, skipping generation"
      return
    }

    println "\nGenerating compose_data.bin from srcs/compose/"
    def jsonFiles = fileTree("srcs/compose").matching { include "*.json" }.files.collect { it.absolutePath }
    def composeSubdir = file("srcs/compose/compose").absolutePath
    exec {
      workingDir = projectDir
      commandLine(["python3", "scripts/generate_compose_bin.py"] + jsonFiles + [composeSubdir])
      ignoreExitValue = false
    }
  }
}

tasks.register('initDebugKeystore') {
  if (!file("debug.keystore").exists()) {
    println "Initializing default debug keystore"
    exec {
      // A shell script might be needed if this line requires input from the user
      commandLine "keytool", "-genkeypair", "-dname", "cn=d, ou=e, o=b, c=ug", "-alias", "debug", "-keypass", "debug0", "-keystore", "debug.keystore", "-keyalg", "rsa", "-storepass", "debug0", "-validity", "10000"
    }
  }
}

// latn_qwerty_us is used as a raw resource by the custom layout option.
tasks.register('copyRawQwertyUS')
{
  copy {
    from "srcs/layouts/latn_qwerty_us.xml"
    into "build/generated-resources/raw"
  }
}

tasks.register('copyLayoutDefinitions')
{
  copy {
    from "src/main/layouts"
    include "*.xml"
    into "build/generated-resources/raw"
  }
}
