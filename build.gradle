plugins {
  id 'com.android.application' version '8.8.2'
  id 'org.jetbrains.kotlin.android' version '1.9.20'
}

dependencies {
  implementation "androidx.window:window-java:1.3.0"
  implementation "androidx.core:core:1.13.1"
  implementation "androidx.appcompat:appcompat:1.6.1"
  implementation "androidx.multidex:multidex:2.0.1"
  implementation "com.google.android.material:material:1.11.0"
  implementation "androidx.viewpager2:viewpager2:1.0.0"
  implementation "androidx.recyclerview:recyclerview:1.3.2"
  implementation "androidx.preference:preference-ktx:1.2.1"

  implementation "org.jetbrains.kotlin:kotlin-stdlib:1.9.20"
  implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3"

  implementation "androidx.activity:activity-compose:1.8.2"
  implementation "androidx.compose.ui:ui:1.5.4"
  debugImplementation "androidx.compose.ui:ui-tooling-preview:1.5.4"
  debugImplementation "androidx.compose.ui:ui-tooling:1.5.4"
  implementation "androidx.compose.material3:material3:1.1.2"
  implementation "androidx.compose.foundation:foundation:1.5.4"

  implementation "androidx.lifecycle:lifecycle-runtime-ktx:2.6.2"
  implementation "androidx.savedstate:savedstate-ktx:1.2.1"

  implementation "org.burnoutcrew.composereorderable:reorderable:0.9.6"
  implementation "com.microsoft.onnxruntime:onnxruntime-android:1.20.0"
  implementation "com.google.code.gson:gson:2.10.1"

  testImplementation "junit:junit:4.13.2"
  testImplementation "org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3"
  testImplementation "org.robolectric:robolectric:4.11.1"
  testImplementation "androidx.test:core:1.5.0"

  androidTestImplementation "androidx.test.ext:junit:1.1.5"
  androidTestImplementation "androidx.test.runner:1.5.2"
  androidTestImplementation "androidx.test.rules:1.5.0"
  androidTestImplementation "org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3"
}

// =============================================================================
// VERSIONING - F-Droid compatible (checkupdates does not parse ext values)
// =============================================================================
// UPDATE ONLY THESE THREE VALUES FOR A NEW RELEASE:
ext.VERSION_MAJOR = 1
ext.VERSION_MINOR = 1
ext.VERSION_PATCH = 34
// =============================================================================
// DERIVED VALUES (auto-calculated, do not edit):
// - versionCode = MAJOR*10000 + MINOR*100 + PATCH
// - versionNameStr = "MAJOR.MINOR.PATCH"
// - ABI versionCode = base*10 + abiCode (1=armv7, 2=arm64, 3=x86_64)
//
// WORKFLOW:
// 1. Update VERSION_MAJOR/MINOR/PATCH above
// 2. Commit, tag with "vX.Y.Z", push tag
// 3. GitHub Actions verifies tag matches version, builds, releases
// 4. F-Droid auto-detects tag and builds
// =============================================================================
ext.versionCode = ext.VERSION_MAJOR * 10000 + ext.VERSION_MINOR * 100 + ext.VERSION_PATCH
ext.versionNameStr = "${ext.VERSION_MAJOR}.${ext.VERSION_MINOR}.${ext.VERSION_PATCH}"

// Per-ABI versionCode mapping for F-Droid split APKs
// Must be at project level for applicationVariants access
ext.abiCodes = ['armeabi-v7a': 1, 'arm64-v8a': 2, 'x86_64': 3]

// Force reproducibility by excluding profile-guided optimization tools
configurations.all {
    exclude group: 'androidx.profileinstaller', module: 'profileinstaller'
}

android {
  namespace 'tribixbite.cleverkeys'
  compileSdk 34

  defaultConfig {
    applicationId "tribixbite.cleverkeys"
    minSdk 21
    targetSdkVersion 34
    
    // References ext values - see VERSION_MAJOR/MINOR/PATCH at top of file
    versionCode rootProject.ext.versionCode
    versionName rootProject.ext.versionNameStr
    
    testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    multiDexEnabled true
  }

  kotlinOptions {
    jvmTarget = "1.8"
  }

  aaptOptions {
    noCompress 'onnx', 'tflite'
    additionalParameters "--no-auto-version"
  }

  packagingOptions {
    // REPRODUCIBILITY: Exclude non-deterministic files using top-level exclude
    // (More effective than resources.excludes for assets)
    exclude "assets/dexopt/baseline.prof"
    exclude "assets/dexopt/baseline.profm"
    exclude "META-INF/version-control-info.textproto"
    exclude "META-INF/com/android/build/gradle/app-metadata.properties"

    resources {
      // Kotlin coroutines service files (non-deterministic order)
      excludes += "META-INF/services/kotlinx.coroutines.internal.MainDispatcherFactory"
      excludes += "META-INF/services/kotlinx.coroutines.CoroutineExceptionHandler"

      // License files and kotlin modules (reduce APK noise)
      excludes += "META-INF/DEPENDENCIES"
      excludes += "META-INF/LICENSE*"
      excludes += "META-INF/NOTICE*"
      excludes += "META-INF/AL2.0"
      excludes += "META-INF/LGPL2.1"
      excludes += "META-INF/*.kotlin_module"
      excludes += "META-INF/*.version"
      excludes += "META-INF/com.android.tools/**"
    }
  }

  // REPRODUCIBILITY: Exclude dependency info from APK
  dependenciesInfo {
    includeInApk = false
    includeInBundle = false
  }

  splits {
    abi {
      enable true
      reset()
      include 'armeabi-v7a', 'arm64-v8a', 'x86_64'
      universalApk false
    }
  }

  compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
  }

  buildFeatures {
    compose true
  }

  composeOptions {
    kotlinCompilerExtensionVersion = '1.5.4'
  }

  sourceSets {
    main {
      manifest.srcFile 'AndroidManifest.xml'
      kotlin.srcDirs = ['src/main/kotlin']
      java.srcDirs = ['src/main/java']
      res.srcDirs = ['res', 'build/generated/layouts/res', 'build/generated/version/res']
      assets.srcDirs = ['assets', 'src/main/assets']
    }
    test {
      kotlin.srcDirs = ['src/test/kotlin']
      java.srcDirs = ['src/test/java']
    }
    androidTest {
      kotlin.srcDirs = ['src/androidTest/kotlin']
    }
  }

  signingConfigs {
    debug {
      storeFile(System.env.DEBUG_KEYSTORE ? file(System.env.DEBUG_KEYSTORE) : file("debug.keystore"))
      storePassword(System.env.DEBUG_KEYSTORE_PASSWORD ? "$System.env.DEBUG_KEYSTORE_PASSWORD" : "debug0")
      keyAlias(System.env.DEBUG_KEY_ALIAS ? "$System.env.DEBUG_KEY_ALIAS" : "debug")
      keyPassword(System.env.DEBUG_KEY_PASSWORD ? "$System.env.DEBUG_KEY_PASSWORD" : "debug0")
    }
    release {
      if (System.env.RELEASE_KEYSTORE) {
        storeFile file(System.env.RELEASE_KEYSTORE)
        storePassword "$System.env.RELEASE_KEYSTORE_PASSWORD"
        keyAlias "$System.env.RELEASE_KEY_ALIAS"
        keyPassword "$System.env.RELEASE_KEY_PASSWORD"
      } else {
        storeFile file("debug.keystore")
        storePassword "debug0"
        keyAlias "debug"
        keyPassword "debug0"
      }
    }
  }

  buildTypes {
    release {
      minifyEnabled true
      shrinkResources false
      debuggable false
      proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
      resValue "string", "app_name", "CleverKeys"
      signingConfig signingConfigs.release
    }
    debug {
      minifyEnabled false
      shrinkResources false
      debuggable true
      resValue "string", "app_name", "CleverKeys (Debug)"
      resValue "bool", "debug_logs", "true"
      signingConfig signingConfigs.debug
    }
  }

  android.applicationVariants.all { variant ->
    variant.outputs.each { output ->
      def abi = output.getFilter(com.android.build.OutputFile.ABI)
      if (abi != null) {
        def abiCode = rootProject.ext.abiCodes.get(abi, 0)
        output.versionCodeOverride = variant.versionCode * 10 + abiCode
        output.outputFileName = "${applicationId}_${variant.versionCode}_${abi}.apk"
      } else {
        output.outputFileName = "${applicationId}_${variant.versionCode}_universal.apk"
      }
    }
  }

  lint {
    baseline = file("lint-baseline.xml")
    abortOnError = false
    checkReleaseBuilds = false
  }

  testOptions {
    unitTests {
      includeAndroidResources = true
      returnDefaultValues = true
    }
  }
}

// Apply Compose determinism fix to all Kotlin compilation tasks exactly once
tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach {
    kotlinOptions {
        freeCompilerArgs += [
            "-P", "plugin:androidx.compose.compiler.plugins.kotlin:sourceInformation=false",
            "-Xrelative-path-base=${projectDir.absolutePath}",
            "-Xbackend-threads=1",
            "-Xno-call-assertions",
            "-Xno-receiver-assertions",
            "-Xno-param-assertions"
        ]
    }
}

// REPRODUCIBILITY: Disable baseline profile compilation for deterministic APKs
// The ART profile varies between build environments and causes reproducibility issues
tasks.configureEach { task ->
    if (task.name.contains("ArtProfile") || task.name.contains("BaselineProfile")) {
        task.enabled = false
    }
}

def isArm64 = System.getProperty("os.arch") in ["aarch64", "arm64"]
if (isArm64) {
  tasks.withType(Test).configureEach {
    enabled = false
  }
}

tasks.register('buildKeyboardFont') {
  def fontFile = file("assets/special_font.ttf")
  if (fontFile.exists()) return
  exec {
    workingDir "$projectDir/srcs/special_font"
    def svgFiles = workingDir.listFiles().findAll { it.isFile() && it.name.endsWith(".svg") }
    commandLine("fontforge", "-lang=ff", "-script", "build.pe", "$buildDir/special_font.ttf", *svgFiles)
  }
  copy { from "$buildDir/special_font.ttf" into "assets" }
}

tasks.register('genEmojis') {
  def outFile = file("res/raw/emojis.txt")
  if (outFile.exists() && outFile.length() > 1000) return
  exec { workingDir = projectDir; commandLine "python3", "gen_emoji.py"; ignoreExitValue = true }
}

tasks.withType(Test).configureEach {
  dependsOn 'genLayoutsList', 'checkKeyboardLayouts', 'generateComposeData'
}

tasks.register('genLayoutsList') {
  def outFile = file("res/values/layouts.xml")
  if (outFile.exists() && outFile.length() > 100) return
  exec { workingDir = projectDir; commandLine "python3", "gen_layouts.py"; ignoreExitValue = true }
}

tasks.register('checkKeyboardLayouts') {
  if (!file("res/values/layouts.xml").exists()) return
  exec { workingDir = projectDir; commandLine "python3", "tools/check_layout.py"; ignoreExitValue = true }
}

tasks.register('generateBinaryDictionaries') {
  doLast {
    def dictDir = file("src/main/assets/dictionaries")
    dictDir.listFiles().findAll { it.name.endsWith(".json") && !it.name.contains("contraction") }.each { jsonFile ->
      def binFile = new File(dictDir, jsonFile.name.replace(".json", ".bin"))
      if (!binFile.exists() || jsonFile.lastModified() > binFile.lastModified()) {
        exec { workingDir = projectDir; commandLine "python3", "scripts/generate_binary_dict.py", jsonFile.absolutePath, binFile.absolutePath }
      }
    }
  }
}

tasks.register('generateBinaryContractions') {
  doLast {
    def dictDir = file("src/main/assets/dictionaries")
    def binFile = new File(dictDir, "contractions.bin")
    if (!binFile.exists()) {
      exec {
        workingDir = projectDir
        commandLine "python3", "scripts/generate_binary_contractions.py",
                    new File(dictDir, "contractions_non_paired.json").absolutePath,
                    new File(dictDir, "contraction_pairings.json").absolutePath,
                    binFile.absolutePath
      }
    }
  }
}

// REPRODUCIBILITY: Generate version info with deterministic fallbacks
// Ensures identical output even when git is unavailable
tasks.register('generateVersionInfo') {
  def outDir = file("${buildDir}/generated/version/res/raw")
  outputs.dir(outDir)
  
  doLast {
    def getGitInfo = { command ->
        try {
            def stdout = new ByteArrayOutputStream()
            def result = exec {
                commandLine command.split()
                standardOutput = stdout
                errorOutput = new ByteArrayOutputStream()
                ignoreExitValue = true
            }
            def output = stdout.toString().trim()
            return (result.exitValue == 0 && output) ? output : null
        } catch (Exception e) {
            return null
        }
    }

    // Use git info if available, otherwise use deterministic fallbacks
    def gitCommit = getGitInfo('git rev-parse --short HEAD') ?: "release"
    def gitCommitFull = getGitInfo('git rev-parse HEAD') ?: "release-${project.ext.versionNameStr}"
    def gitDate = getGitInfo('git log -1 --format=%cd --date=short') ?: "2025-01-01"

    outDir.mkdirs()
    def versionFile = new File(outDir, "version_info.txt")
    versionFile.text = """\
commit=${gitCommit}
commit_full=${gitCommitFull}
commit_date=${gitDate}
version=${project.ext.versionNameStr}
"""
    println "Generated version_info.txt in ${versionFile.absolutePath}: commit=${gitCommit}, date=${gitDate}"
  }
}

tasks.named("preBuild") {
  dependsOn "initDebugKeystore", "copyRawQwertyUS", "copyLayoutDefinitions", "generateBinaryDictionaries", "generateBinaryContractions", "generateComposeData", "generateVersionInfo"
}

tasks.register('generateComposeData') {
  doLast {
    def composeDir = file("srcs/compose")
    def outputBin = file("src/main/assets/compose_data.bin")
    def outputKt = file("src/main/kotlin/tribixbite/cleverkeys/ComposeKeyData.kt")
    if (outputBin.exists() && outputKt.exists()) return
    def jsonFiles = fileTree("srcs/compose").matching { include "*.json" }.files.collect { it.absolutePath }
    exec { workingDir = projectDir; commandLine(["python3", "scripts/generate_compose_bin.py"] + jsonFiles + [file("srcs/compose/compose").absolutePath]) }
  }
}

tasks.register('initDebugKeystore') {
  if (!file("debug.keystore").exists()) {
    exec { commandLine "keytool", "-genkeypair", "-dname", "cn=d, ou=e, o=b, c=ug", "-alias", "debug", "-keypass", "debug0", "-keystore", "debug.keystore", "-keyalg", "rsa", "-storepass", "debug0", "-validity", "10000" }
  }
}

tasks.register('copyRawQwertyUS', Copy) { from "srcs/layouts/latn_qwerty_us.xml"; into "build/generated/layouts/res/raw" }
tasks.register('copyLayoutDefinitions', Copy) { from "src/main/layouts"; include "*.xml"; into "build/generated/layouts/res/raw" }

tasks.register("printR8Version") {
    doLast {
        try {
            def r8Class = Class.forName("com.android.tools.r8.Version")
            println "R8 Version: ${r8Class.getVersionString()}"
        } catch (Exception e) {
            println "R8 Version not found in classpath"
        }
    }
}

// REPRODUCIBILITY: Normalize APK resource paths by removing -v4 suffixes
// This fixes AAPT2 adding non-deterministic version qualifiers to resource paths
tasks.register("normalizeApkPaths") {
    description = "Normalize APK resource paths for reproducibility"
    group = "build"

    // Only run after release builds
    mustRunAfter tasks.matching { it.name.startsWith("assemble") && it.name.contains("Release") }

    doLast {
        def apkDir = file("${buildDir}/outputs/apk/release")
        if (!apkDir.exists()) {
            println "No release APKs found to normalize"
            return
        }

        def scriptPath = file("${projectDir}/scripts/normalize_apk.py")
        if (!scriptPath.exists()) {
            println "Warning: normalize_apk.py not found at ${scriptPath}"
            return
        }

        // Get signing config
        def keystorePath = System.env.RELEASE_KEYSTORE ?: file("debug.keystore").absolutePath
        def keyAlias = System.env.RELEASE_KEY_ALIAS ?: "debug"
        def storePass = System.env.RELEASE_KEYSTORE_PASSWORD ?: "debug0"
        def keyPass = System.env.RELEASE_KEY_PASSWORD ?: "debug0"

        apkDir.listFiles()?.findAll { it.name.endsWith(".apk") }?.each { apkFile ->
            println "Normalizing: ${apkFile.name}"
            def normalizedApk = new File(apkFile.parentFile, apkFile.name.replace(".apk", "_normalized.apk"))

            try {
                exec {
                    commandLine "python3", scriptPath.absolutePath,
                        apkFile.absolutePath,
                        normalizedApk.absolutePath,
                        "--sign",
                        "--keystore", keystorePath,
                        "--key-alias", keyAlias,
                        "--store-pass", storePass,
                        "--key-pass", keyPass
                }

                // Replace original with normalized
                if (normalizedApk.exists()) {
                    apkFile.delete()
                    normalizedApk.renameTo(apkFile)
                    println "Normalized: ${apkFile.name}"
                }
            } catch (Exception e) {
                println "Warning: Failed to normalize ${apkFile.name}: ${e.message}"
            }
        }
    }
}

// Hook normalization into release builds
tasks.configureEach { task ->
    if (task.name == "assembleRelease") {
        task.finalizedBy("normalizeApkPaths")
    }
}
