plugins {
  id 'com.android.application' version '8.6.0'
  id 'org.jetbrains.kotlin.android' version '1.9.20'
}

dependencies {
  implementation "androidx.window:window-java:1.3.0"
  implementation "androidx.core:core:1.13.1"  // Downgraded from 1.16.0 - last version supporting SDK 34
  implementation "androidx.appcompat:appcompat:1.6.1"
  implementation "androidx.multidex:multidex:2.0.1"
  implementation "com.google.android.material:material:1.11.0"
  implementation "androidx.viewpager2:viewpager2:1.0.0"
  implementation "androidx.recyclerview:recyclerview:1.3.2"
  implementation "androidx.preference:preference-ktx:1.2.1"

  // Kotlin dependencies
  implementation "org.jetbrains.kotlin:kotlin-stdlib:1.9.20"
  implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3"

  // Jetpack Compose dependencies (for settings UI)
  implementation "androidx.activity:activity-compose:1.8.2"
  implementation "androidx.compose.ui:ui:1.5.4"
  implementation "androidx.compose.ui:ui-tooling-preview:1.5.4"
  // CRITICAL: ui-tooling must be debugImplementation only!
  // As implementation, it embeds compose_data.bin with machine-specific paths,
  // breaking F-Droid reproducible builds (diffoscope shows 51958 vs 51928 bytes)
  debugImplementation "androidx.compose.ui:ui-tooling:1.5.4"
  implementation "androidx.compose.material3:material3:1.1.2"
  implementation "androidx.compose.foundation:foundation:1.5.4"

  // Lifecycle dependencies for Compose in InputMethodService (Fix ViewTreeLifecycleOwner crash)
  implementation "androidx.lifecycle:lifecycle-runtime-ktx:2.6.2"
  implementation "androidx.savedstate:savedstate-ktx:1.2.1"

  // Reorderable for drag-and-drop in Layout Manager
  implementation "org.burnoutcrew.composereorderable:reorderable:0.9.6"

  // ONNX Runtime for neural swipe prediction (upgraded for boolean tensor support)
  implementation "com.microsoft.onnxruntime:onnxruntime-android:1.20.0"

  // Gson for JSON serialization/deserialization (backup/restore functionality)
  implementation "com.google.code.gson:gson:2.10.1"

  testImplementation "junit:junit:4.13.2"
  testImplementation "org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3"
  testImplementation "org.robolectric:robolectric:4.11.1"
  testImplementation "androidx.test:core:1.5.0"

  // Android instrumentation test dependencies
  androidTestImplementation "androidx.test.ext:junit:1.1.5"
  androidTestImplementation "androidx.test:runner:1.5.2"
  androidTestImplementation "androidx.test:rules:1.5.0"
  androidTestImplementation "org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3"
}

// =============================================================================
// SINGLE SOURCE OF TRUTH - VERSIONING
// =============================================================================
// UPDATE ONLY THESE THREE VALUES FOR A NEW RELEASE:
ext.VERSION_MAJOR = 1
ext.VERSION_MINOR = 0
ext.VERSION_PATCH = 7
// =============================================================================
// DERIVED VALUES (auto-calculated, do not edit):
// - versionCode = MAJOR*10000 + MINOR*100 + PATCH
// - versionNameStr = "MAJOR.MINOR.PATCH"
// - ABI versionCode = base*10 + abiCode (1=armv7, 2=arm64, 3=x86_64)
//
// WORKFLOW:
// 1. Update VERSION_MAJOR/MINOR/PATCH above
// 2. Commit, tag with "vX.Y.Z", push tag
// 3. GitHub Actions verifies tag matches version, builds, releases
// 4. F-Droid auto-detects tag and builds
// =============================================================================
ext.versionCode = ext.VERSION_MAJOR * 10000 + ext.VERSION_MINOR * 100 + ext.VERSION_PATCH
ext.versionNameStr = "${ext.VERSION_MAJOR}.${ext.VERSION_MINOR}.${ext.VERSION_PATCH}"

def getVersionFromTag() {
    try {
        // Get the most recent tag matching vX.Y.Z pattern
        def tag = 'git describe --tags --match "v[0-9]*.[0-9]*.[0-9]*" --abbrev=0'.execute().text.trim()
        if (tag && tag.startsWith('v')) {
            return tag.substring(1) // Remove 'v' prefix
        }
    } catch (ignored) {}
    return null
}

def getVersionInfo() {
    def tagVersion = getVersionFromTag()

    if (tagVersion) {
        // Parse semantic version from tag
        def parts = tagVersion.split('\\.')
        if (parts.length >= 3) {
            def major = parts[0].toInteger()
            def minor = parts[1].toInteger()
            def patch = parts[2].replaceAll('[^0-9]', '').toInteger()

            // Check if current commit is exactly on the tag
            def tagCommit = "git rev-list -n 1 v${tagVersion}".execute().text.trim()
            def headCommit = 'git rev-parse HEAD'.execute().text.trim()
            def isRelease = tagCommit == headCommit

            def versionCode = major * 10000 + minor * 100 + patch
            def versionName = isRelease ? tagVersion : "${tagVersion}-dev"

            println "ðŸ“¦ CleverKeys version: ${versionName} (code: ${versionCode}, release: ${isRelease})"
            return [code: versionCode, name: versionName, isRelease: isRelease]
        }
    }

    // Fallback for untagged/development builds
    try {
        def shortSha = 'git rev-parse --short HEAD'.execute().text.trim()
        println "ðŸ”§ CleverKeys development build: dev-${shortSha}"
        return [code: 1, name: "dev-${shortSha}", isRelease: false]
    } catch (ignored) {
        println "âš ï¸ Git not available, using fallback version"
        return [code: 1, name: "dev-unknown", isRelease: false]
    }
}

// Cache version info to avoid multiple git calls
ext.versionInfo = getVersionInfo()

def getVersionCode() {
    return ext.versionInfo.code
}

def getVersionName() {
    return ext.versionInfo.name
}

// Per-ABI versionCode mapping for F-Droid split APKs
// Must be at project level for applicationVariants access
ext.abiCodes = ['armeabi-v7a': 1, 'arm64-v8a': 2, 'x86_64': 3]

android {
  namespace 'tribixbite.cleverkeys'
  compileSdk 34  // Lowered from 35 for F-Droid androguard compatibility

  defaultConfig {
    applicationId "tribixbite.cleverkeys"
    minSdk 21
    targetSdkVersion 34  // Lowered from 35 for F-Droid androguard compatibility
    // References the single source of truth from ext block - NO DUPLICATION
    versionCode rootProject.ext.versionCode
    versionName rootProject.ext.versionNameStr
    testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    multiDexEnabled true
  }

  // ABI splits for smaller APKs (~25MB each vs ~75MB universal)
  // F-Droid uses separate build entries with output: field to pick specific ABI
  splits {
    abi {
      enable true
      reset()
      include 'armeabi-v7a', 'arm64-v8a', 'x86_64'
      universalApk false  // F-Droid builds each ABI separately
    }
  }

  compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
  }

  kotlinOptions {
    jvmTarget = "1.8"
  }

  buildFeatures {
    compose true
  }

  composeOptions {
    kotlinCompilerExtensionVersion = '1.5.4'
  }

  sourceSets {
    main {
      manifest.srcFile 'AndroidManifest.xml'
      kotlin.srcDirs = ['src/main/kotlin']
      java.srcDirs = ['src/main/java']
      res.srcDirs = ['res', 'build/generated-resources']
      assets.srcDirs = ['assets', 'src/main/assets']
    }

    test {
      kotlin.srcDirs = ['src/test/kotlin']
      java.srcDirs = ['src/test/java']
    }

    androidTest {
      kotlin.srcDirs = ['src/androidTest/kotlin']
    }
  }

  signingConfigs {
    // Debug builds will always be signed. If no environment variables are set, a default
    // keystore will be initialized by the task initDebugKeystore and used. This keystore
    // can be uploaded to GitHub secrets by following instructions in CONTRIBUTING.md
    // in order to always receive correctly signed debug APKs from the CI.
    debug {
      storeFile(System.env.DEBUG_KEYSTORE ? file(System.env.DEBUG_KEYSTORE) : file("debug.keystore"))
      storePassword(System.env.DEBUG_KEYSTORE_PASSWORD ? "$System.env.DEBUG_KEYSTORE_PASSWORD" : "debug0")
      keyAlias(System.env.DEBUG_KEY_ALIAS ? "$System.env.DEBUG_KEY_ALIAS" : "debug")
      keyPassword(System.env.DEBUG_KEY_PASSWORD ? "$System.env.DEBUG_KEY_PASSWORD" : "debug0")
    }

    release {
      // Use release keystore if available, otherwise fall back to debug for local testing
      if (System.env.RELEASE_KEYSTORE) {
        storeFile file(System.env.RELEASE_KEYSTORE)
        storePassword "$System.env.RELEASE_KEYSTORE_PASSWORD"
        keyAlias "$System.env.RELEASE_KEY_ALIAS"
        keyPassword "$System.env.RELEASE_KEY_PASSWORD"
      } else {
        // Fallback to debug keystore for local release builds (F-Droid signs with their own key)
        storeFile file("debug.keystore")
        storePassword "debug0"
        keyAlias "debug"
        keyPassword "debug0"
      }
    }
  }

  buildTypes {
    release {
      minifyEnabled true
      shrinkResources true
      debuggable false
      proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
      resValue "string", "app_name", "CleverKeys"
      signingConfig signingConfigs.release
    }

    debug {
      // FIX: Removed applicationIdSuffix ".debug" to fix keyboard service crash
      // The .debug suffix prevented Android from properly binding InputMethodService
      minifyEnabled false
      shrinkResources false
      debuggable true
      // applicationIdSuffix ".debug"  // DO NOT ADD THIS BACK - it breaks IME binding!
      resValue "string", "app_name", "CleverKeys (Debug)"
      resValue "bool", "debug_logs", "true"
      signingConfig signingConfigs.debug
    }
  }

  // Name outputs with ABI and apply per-ABI versionCode for F-Droid
  android.applicationVariants.all { variant ->
    variant.outputs.each { output ->
      def abi = output.getFilter(com.android.build.OutputFile.ABI)
      if (abi != null) {
        // Per-ABI versionCode: base * 10 + abiCode
        def abiCode = rootProject.ext.abiCodes.get(abi, 0)
        output.versionCodeOverride = variant.versionCode * 10 + abiCode
        // Name: tribixbite.cleverkeys_1593_arm64-v8a.apk
        output.outputFileName = "${applicationId}_${variant.versionCode}_${abi}.apk"
      } else {
        output.outputFileName = "${applicationId}_${variant.versionCode}_universal.apk"
      }
    }
  }

  compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
  }

  lint {
    baseline = file("lint-baseline.xml")
    abortOnError = false
    checkReleaseBuilds = false
  }

  testOptions {
    unitTests {
      includeAndroidResources = true
      returnDefaultValues = true
    }
  }
}

// Skip Robolectric tests on ARM64 (no Conscrypt native libraries available)
def isArm64 = System.getProperty("os.arch") in ["aarch64", "arm64"]
if (isArm64) {
  tasks.withType(Test).configureEach {
    enabled = false
    println "âš ï¸ Skipping unit tests on ARM64 architecture (Robolectric requires x86_64)"
  }
}

tasks.register('buildKeyboardFont') {
  // Skip font building if font already exists
  def fontFile = file("assets/special_font.ttf")
  if (fontFile.exists()) {
    println "\nSpecial font already exists, skipping build"
    return
  }

  println "\nBuilding assets/special_font.ttf"
  mkdir "$buildDir"
  exec {
    workingDir "$projectDir/srcs/special_font"
    def svgFiles = workingDir.listFiles().findAll {
      it.isFile() && it.name.endsWith(".svg")
    }
    commandLine("fontforge", "-lang=ff", "-script", "build.pe", "$buildDir/special_font.ttf", *svgFiles)
  }
  copy {
    from "$buildDir/special_font.ttf"
    into "assets"
  }
}

tasks.register('genEmojis') {
  def outFile = file("res/raw/emojis.txt")
  // Skip if output already exists
  if (outFile.exists() && outFile.length() > 1000) {
    println "\nEmojis.txt already exists, skipping generation"
    return
  }
  println "\nGenerating res/raw/emojis.txt"
  exec {
    workingDir = projectDir
    commandLine "python3", "gen_emoji.py"
    ignoreExitValue = true  // Don't fail CI if python script unavailable
  }
}

tasks.withType(Test).configureEach {
  dependsOn 'genLayoutsList'
  dependsOn 'checkKeyboardLayouts'
  dependsOn 'generateComposeData'
}

tasks.register('genLayoutsList') {
  def outFile = file("res/values/layouts.xml")
  // Skip if output already exists
  if (outFile.exists() && outFile.length() > 100) {
    println "\nLayouts.xml already exists, skipping generation"
    return
  }
  println "\nGenerating res/values/layouts.xml"
  exec {
    workingDir = projectDir
    commandLine "python3", "gen_layouts.py"
    ignoreExitValue = true  // Don't fail CI if python script unavailable
  }
}

tasks.register('checkKeyboardLayouts') {
  // Skip layout check on CI (python dependencies may not be available)
  def genLayoutsFile = file("res/values/layouts.xml")
  if (!genLayoutsFile.exists()) {
    println "\nâš ï¸ Skipping layout check - layouts.xml not found"
    return
  }
  println "\nChecking layouts"
  exec {
    workingDir = projectDir
    commandLine("python3", "tools/check_layout.py")
    ignoreExitValue = true  // Don't fail CI if check script fails
  }
}

// compileComposeSequences removed - use generateComposeData instead

tasks.register('generateBinaryDictionaries') {
  description 'Generate optimized binary dictionaries from JSON sources'
  doLast {
    def dictDir = file("src/main/assets/dictionaries")
    def jsonFiles = dictDir.listFiles().findAll { it.name.endsWith(".json") && !it.name.contains("contraction") }

    jsonFiles.each { jsonFile ->
      def binFile = new File(dictDir, jsonFile.name.replace(".json", ".bin"))

      // Only regenerate if JSON is newer than binary, or binary doesn't exist
      if (!binFile.exists() || jsonFile.lastModified() > binFile.lastModified()) {
        println "Generating binary dictionary: ${binFile.name}"
        exec {
          workingDir = projectDir
          commandLine "python3", "scripts/generate_binary_dict.py", jsonFile.absolutePath, binFile.absolutePath
        }
      } else {
        println "Binary dictionary up-to-date: ${binFile.name}"
      }
    }
  }
}

tasks.register('generateBinaryContractions') {
  description 'Generate optimized binary contractions from JSON sources'
  doLast {
    def dictDir = file("src/main/assets/dictionaries")
    def nonPairedFile = new File(dictDir, "contractions_non_paired.json")
    def pairedFile = new File(dictDir, "contraction_pairings.json")
    def binFile = new File(dictDir, "contractions.bin")

    // Only regenerate if either JSON is newer than binary, or binary doesn't exist
    def needsRegenerate = !binFile.exists() ||
                          nonPairedFile.lastModified() > binFile.lastModified() ||
                          pairedFile.lastModified() > binFile.lastModified()

    if (needsRegenerate) {
      println "Generating binary contractions: ${binFile.name}"
      exec {
        workingDir = projectDir
        commandLine "python3", "scripts/generate_binary_contractions.py",
                    nonPairedFile.absolutePath,
                    pairedFile.absolutePath,
                    binFile.absolutePath
      }
    } else {
      println "Binary contractions up-to-date: ${binFile.name}"
    }
  }
}

tasks.register('generateVersionInfo') {
  doLast {
    def gitCommit = 'git rev-parse --short HEAD'.execute().text.trim()
    def gitCommitFull = 'git rev-parse HEAD'.execute().text.trim()
    def gitDate = 'git log -1 --format=%cd --date=short'.execute().text.trim()
    def buildDate = new Date().format('yyyy-MM-dd HH:mm:ss')
    def buildNumber = System.currentTimeMillis().toString()

    def versionFile = file("build/generated-resources/raw/version_info.txt")
    versionFile.parentFile.mkdirs()
    versionFile.text = """commit=$gitCommit
commit_full=$gitCommitFull
commit_date=$gitDate
build_date=$buildDate
build_number=$buildNumber
"""

    println "Generated version info: $gitCommit ($gitDate)"
  }
}

tasks.named("preBuild") {
  dependsOn += "initDebugKeystore"
  dependsOn += "copyRawQwertyUS"
  dependsOn += "copyLayoutDefinitions"
  dependsOn += "generateBinaryDictionaries"
  dependsOn += "generateBinaryContractions"
  dependsOn += "generateComposeData"
  dependsOn += "generateVersionInfo"
}

tasks.register('generateComposeData') {
  description 'Generate compose_data.bin from compose sequence sources'
  doLast {
    def composeDir = file("srcs/compose")
    def outputBin = file("src/main/assets/compose_data.bin")
    def outputKt = file("src/main/kotlin/tribixbite/cleverkeys/ComposeKeyData.kt")

    // Skip if output exists and is newer than all sources
    def sourceFiles = composeDir.listFiles().findAll {
      it.name.endsWith(".json") || it.isDirectory()
    }
    def latestSource = sourceFiles.collect {
      it.isDirectory() ? it.listFiles()?.collect { f -> f.lastModified() }?.max() ?: 0 : it.lastModified()
    }.max() ?: 0

    if (outputBin.exists() && outputKt.exists() &&
        outputBin.lastModified() > latestSource &&
        outputKt.lastModified() > latestSource) {
      println "\nCompose data up-to-date, skipping generation"
      return
    }

    println "\nGenerating compose_data.bin from srcs/compose/"
    def jsonFiles = fileTree("srcs/compose").matching { include "*.json" }.files.collect { it.absolutePath }
    def composeSubdir = file("srcs/compose/compose").absolutePath
    exec {
      workingDir = projectDir
      commandLine(["python3", "scripts/generate_compose_bin.py"] + jsonFiles + [composeSubdir])
      ignoreExitValue = false
    }
  }
}

tasks.register('initDebugKeystore') {
  if (!file("debug.keystore").exists()) {
    println "Initializing default debug keystore"
    exec {
      // A shell script might be needed if this line requires input from the user
      commandLine "keytool", "-genkeypair", "-dname", "cn=d, ou=e, o=b, c=ug", "-alias", "debug", "-keypass", "debug0", "-keystore", "debug.keystore", "-keyalg", "rsa", "-storepass", "debug0", "-validity", "10000"
    }
  }
}

// latn_qwerty_us is used as a raw resource by the custom layout option.
tasks.register('copyRawQwertyUS', Copy)
{
  from "srcs/layouts/latn_qwerty_us.xml"
  into "build/generated-resources/raw"
}

tasks.register('copyLayoutDefinitions', Copy)
{
  from "src/main/layouts"
  include "*.xml"
  into "build/generated-resources/raw"
}
