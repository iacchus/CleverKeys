<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture System - CleverKeys Documentation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        'ck-purple': '#9b59b6',
                        'ck-purple-dark': '#6b21a8',
                        'ck-purple-light': '#c39bd3',
                        'ck-dark': '#0f0f1a',
                        'ck-surface': '#1a1a2e',
                        'ck-card': '#242438',
                    }
                }
            }
        }
    </script>
    <style>
        .gradient-text {
            background: linear-gradient(135deg, #9b59b6 0%, #c39bd3 50%, #9b59b6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
    </style>
</head>
<body class="bg-ck-dark text-gray-100 min-h-screen">
    <!-- Nav -->
    <nav class="sticky top-0 bg-ck-dark/95 backdrop-blur border-b border-gray-800 z-50">
        <div class="container mx-auto px-6 py-4 flex justify-between items-center">
            <a href="../" class="flex items-center gap-3">
                <img src="https://raw.githubusercontent.com/tribixbite/CleverKeys/main/res/mipmap-xxxhdpi/ic_launcher.png" alt="CleverKeys" class="w-8 h-8 rounded-lg">
                <span class="font-bold">CleverKeys</span>
            </a>
            <div class="flex gap-4">
                <a href="./" class="text-gray-400 hover:text-white transition-colors">All Specs</a>
                <a href="../" class="text-gray-400 hover:text-white transition-colors">Home</a>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <div class="container mx-auto px-6 py-4 pt-20">
        <div class="flex items-center gap-2 text-sm text-gray-500">
            <a href="../" class="hover:text-ck-purple">Home</a>
            <span>/</span>
            <a href="./" class="hover:text-ck-purple">Specs</a>
            <span>/</span>
            <span class="text-gray-300">Gesture System</span>
        </div>
    </div>

    <!-- Header -->
    <header class="container mx-auto px-6 pb-8">
        <div class="flex items-center gap-3 mb-4">
            <span class="px-3 py-1 text-sm rounded-full" style="background: #9b59b620; color: #9b59b6">Core</span>
            <span class="px-3 py-1 text-sm rounded-full bg-ck-card text-gray-400">v1.0.0</span>
        </div>
        <h1 class="text-4xl font-bold gradient-text mb-2">Gesture System</h1>
        <p class="text-xl text-gray-400">Swipe detection, multi-touch, and gesture trails</p>
    </header>

    <!-- Content -->
    <main class="container mx-auto px-6 pb-20">
        <div class="bg-ck-surface rounded-2xl p-8 max-w-4xl">
            <h1 class="text-3xl font-bold mb-6 gradient-text">Gesture Recognition System</h1>

<h2 class="text-2xl font-bold mt-8 mb-4 text-ck-purple">Overview</h2>

<p class="mb-4 text-gray-300">CleverKeys implements a multi-layered gesture recognition system that handles four gesture types: short swipes (directional swipes within a key for sublabels), long swipes (gestures across keys for neural word prediction), circle/rotation gestures (for double letters), and slider gestures (continuous value adjustment). The <code class="bg-ck-dark px-1 rounded">hasLeftStartingKey</code> flag is the central decision point that routes touches to the appropriate handler.</p>

<h2 class="text-2xl font-bold mt-8 mb-4 text-ck-purple">Key Files</h2>

<table class="w-full mb-4 border-collapse"><thead class="border-b border-gray-700"><tr><th class="px-4 py-2 text-left font-semibold text-ck-purple-light">File</th><th class="px-4 py-2 text-left font-semibold text-ck-purple-light">Class/Function</th><th class="px-4 py-2 text-left font-semibold text-ck-purple-light">Purpose</th></tr></thead><tbody><tr class="border-b border-gray-800"><td class="px-4 py-2 text-gray-300"><code class="bg-ck-dark px-1 rounded">src/main/kotlin/tribixbite/cleverkeys/Pointers.kt</code></td><td class="px-4 py-2 text-gray-300"><code class="bg-ck-dark px-1 rounded">Pointers</code></td><td class="px-4 py-2 text-gray-300">Touch event handling, gesture pipeline routing (~1100 lines)</td></tr><tr class="border-b border-gray-800"><td class="px-4 py-2 text-gray-300"><code class="bg-ck-dark px-1 rounded">src/main/kotlin/tribixbite/cleverkeys/GestureClassifier.kt</code></td><td class="px-4 py-2 text-gray-300"><code class="bg-ck-dark px-1 rounded">GestureClassifier</code></td><td class="px-4 py-2 text-gray-300">TAP vs SWIPE classification (65 lines)</td></tr><tr class="border-b border-gray-800"><td class="px-4 py-2 text-gray-300"><code class="bg-ck-dark px-1 rounded">src/main/kotlin/tribixbite/cleverkeys/Gesture.kt</code></td><td class="px-4 py-2 text-gray-300"><code class="bg-ck-dark px-1 rounded">Gesture</code></td><td class="px-4 py-2 text-gray-300">Circle/rotation state machine (141 lines)</td></tr><tr class="border-b border-gray-800"><td class="px-4 py-2 text-gray-300"><code class="bg-ck-dark px-1 rounded">src/main/kotlin/tribixbite/cleverkeys/Config.kt</code></td><td class="px-4 py-2 text-gray-300">Gesture settings</td><td class="px-4 py-2 text-gray-300">Configuration thresholds</td></tr><tr class="border-b border-gray-800"><td class="px-4 py-2 text-gray-300"><code class="bg-ck-dark px-1 rounded">src/main/kotlin/tribixbite/cleverkeys/Keyboard2View.kt</code></td><td class="px-4 py-2 text-gray-300"><code class="bg-ck-dark px-1 rounded">getKeyHypotenuse()</code></td><td class="px-4 py-2 text-gray-300">Key dimension calculation</td></tr></tbody></table>
<h2 class="text-2xl font-bold mt-8 mb-4 text-ck-purple">Architecture</h2>

<pre class="bg-ck-dark p-4 rounded-lg overflow-x-auto"><code class="language-text">Touch Events (Keyboard2View.onTouchEvent)
           │
           ▼
      Pointers.kt
           │
     ┌─────┴─────┐
     │           │
  onTouchMove  onTouchUp
     │           │
     ▼           ▼
┌─────────┐  ┌──────────────────┐
│ Track   │  │ GestureClassifier │
│ hasLeft │  │    .classify()    │
│ Starting│  └────────┬─────────┘
│ Key     │           │
└─────────┘    ┌──────┴──────┐
               │             │
          SWIPE           TAP
               │             │
               ▼             ▼
        Neural Predictor  Short Gesture
        (onSwipeEnd)      Handler</code></pre>

<h2 class="text-2xl font-bold mt-8 mb-4 text-ck-purple">Data Flow</h2>

<h3 class="text-xl font-semibold mt-6 mb-3 text-ck-purple-light">Touch Tracking</h3>

<ul class="mb-4 space-y-1"><li class="ml-4">1. <code class="bg-ck-dark px-1 rounded">onTouchDown</code>: Record start position, identify starting key</li>
<li class="ml-4">2. <code class="bg-ck-dark px-1 rounded">onTouchMove</code>: Update position, check if left starting key</li>
<li class="ml-4">3. <code class="bg-ck-dark px-1 rounded">onTouchUp</code>: Classify gesture, trigger appropriate handler</li>
</ul>
<h3 class="text-xl font-semibold mt-6 mb-3 text-ck-purple-light">The <code class="bg-ck-dark px-1 rounded">hasLeftStartingKey</code> Gatekeeper</h3>

<p class="mb-4 text-gray-300">This boolean flag is the single decision point determining gesture type:</p>

<pre class="bg-ck-dark p-4 rounded-lg overflow-x-auto"><code class="language-kotlin">// Pointers.kt, onTouchMove handler
if (ptr.key != null &amp;&amp; !ptr.hasLeftStartingKey) {
    val keyHypotenuse = _handler.getKeyHypotenuse(ptr.key)
    val maxAllowedDistance = keyHypotenuse * (config.short_gesture_max_distance / 100.0f)
    val distanceFromStart = sqrt((x - ptr.downX).pow(2) + (y - ptr.downY).pow(2))

    if (distanceFromStart &gt; maxAllowedDistance) {
        ptr.hasLeftStartingKey = true  // Permanently set for this touch
    }
}</code></pre>

<h2 class="text-2xl font-bold mt-8 mb-4 text-ck-purple">Configuration</h2>

<table class="w-full mb-4 border-collapse"><thead class="border-b border-gray-700"><tr><th class="px-4 py-2 text-left font-semibold text-ck-purple-light">Key</th><th class="px-4 py-2 text-left font-semibold text-ck-purple-light">Type</th><th class="px-4 py-2 text-left font-semibold text-ck-purple-light">Default</th><th class="px-4 py-2 text-left font-semibold text-ck-purple-light">Description</th></tr></thead><tbody><tr class="border-b border-gray-800"><td class="px-4 py-2 text-gray-300"><code class="bg-ck-dark px-1 rounded">short_gesture_min_distance</code></td><td class="px-4 py-2 text-gray-300">Int</td><td class="px-4 py-2 text-gray-300">15</td><td class="px-4 py-2 text-gray-300">Min pixels for short swipe detection</td></tr><tr class="border-b border-gray-800"><td class="px-4 py-2 text-gray-300"><code class="bg-ck-dark px-1 rounded">short_gesture_max_distance</code></td><td class="px-4 py-2 text-gray-300">Int</td><td class="px-4 py-2 text-gray-300">50</td><td class="px-4 py-2 text-gray-300">Max % of key hypotenuse for short swipe (above = long swipe)</td></tr><tr class="border-b border-gray-800"><td class="px-4 py-2 text-gray-300"><code class="bg-ck-dark px-1 rounded">tap_duration_threshold</code></td><td class="px-4 py-2 text-gray-300">Long</td><td class="px-4 py-2 text-gray-300">200</td><td class="px-4 py-2 text-gray-300">Max ms for tap vs swipe distinction</td></tr><tr class="border-b border-gray-800"><td class="px-4 py-2 text-gray-300"><code class="bg-ck-dark px-1 rounded">swipe_speed_threshold</code></td><td class="px-4 py-2 text-gray-300">Float</td><td class="px-4 py-2 text-gray-300">0.4</td><td class="px-4 py-2 text-gray-300">Min speed for swipe typing activation</td></tr><tr class="border-b border-gray-800"><td class="px-4 py-2 text-gray-300"><code class="bg-ck-dark px-1 rounded">circle_gesture_enabled</code></td><td class="px-4 py-2 text-gray-300">Boolean</td><td class="px-4 py-2 text-gray-300">true</td><td class="px-4 py-2 text-gray-300">Enable circle gestures for double letters</td></tr></tbody></table>
<h2 class="text-2xl font-bold mt-8 mb-4 text-ck-purple">Public API</h2>

<h3 class="text-xl font-semibold mt-6 mb-3 text-ck-purple-light">GestureClassifier</h3>

<pre class="bg-ck-dark p-4 rounded-lg overflow-x-auto"><code class="language-kotlin">class GestureClassifier(private val context: Context) {

    enum class GestureType { TAP, SWIPE }

    data class GestureData(
        val hasLeftStartingKey: Boolean,
        val totalDistance: Float,
        val timeElapsed: Long,
        val keyWidth: Float
    )

    fun classify(gesture: GestureData): GestureType {
        val minSwipeDistance = gesture.keyWidth / 2.0f

        return if (gesture.hasLeftStartingKey &amp;&amp;
                   (gesture.totalDistance &gt;= minSwipeDistance ||
                    gesture.timeElapsed &gt; maxTapDurationMs)) {
            GestureType.SWIPE
        } else {
            GestureType.TAP
        }
    }
}</code></pre>

<h3 class="text-xl font-semibold mt-6 mb-3 text-ck-purple-light">Pointers Touch Handlers</h3>

<pre class="bg-ck-dark p-4 rounded-lg overflow-x-auto"><code class="language-kotlin">class Pointers(
    private val handler: Handler,
    private val config: Config
) {
    // Called from Keyboard2View.onTouchEvent
    fun onTouchEvent(event: MotionEvent): Boolean

    // Internal handlers
    private fun onTouchDown(ptr: Pointer, x: Float, y: Float)
    private fun onTouchMove(ptr: Pointer, x: Float, y: Float)
    private fun onTouchUp(ptr: Pointer)

    // Gesture routing
    private fun handleShortGesture(ptr: Pointer, direction: SwipeDirection)
    private fun handleSwipeTyping(ptr: Pointer)
}</code></pre>

<h2 class="text-2xl font-bold mt-8 mb-4 text-ck-purple">Implementation Details</h2>

<h3 class="text-xl font-semibold mt-6 mb-3 text-ck-purple-light">Gesture Classification Logic</h3>

<table class="w-full mb-4 border-collapse"><thead class="border-b border-gray-700"><tr><th class="px-4 py-2 text-left font-semibold text-ck-purple-light">hasLeftStartingKey</th><th class="px-4 py-2 text-left font-semibold text-ck-purple-light">Distance</th><th class="px-4 py-2 text-left font-semibold text-ck-purple-light">Time</th><th class="px-4 py-2 text-left font-semibold text-ck-purple-light">Result</th></tr></thead><tbody><tr class="border-b border-gray-800"><td class="px-4 py-2 text-gray-300">FALSE</td><td class="px-4 py-2 text-gray-300">any</td><td class="px-4 py-2 text-gray-300">any</td><td class="px-4 py-2 text-gray-300">TAP</td></tr><tr class="border-b border-gray-800"><td class="px-4 py-2 text-gray-300">TRUE</td><td class="px-4 py-2 text-gray-300">< keyWidth/2</td><td class="px-4 py-2 text-gray-300"><= tap_duration</td><td class="px-4 py-2 text-gray-300">TAP</td></tr><tr class="border-b border-gray-800"><td class="px-4 py-2 text-gray-300">TRUE</td><td class="px-4 py-2 text-gray-300">>= keyWidth/2</td><td class="px-4 py-2 text-gray-300">any</td><td class="px-4 py-2 text-gray-300">SWIPE</td></tr><tr class="border-b border-gray-800"><td class="px-4 py-2 text-gray-300">TRUE</td><td class="px-4 py-2 text-gray-300">any</td><td class="px-4 py-2 text-gray-300">> tap_duration</td><td class="px-4 py-2 text-gray-300">SWIPE</td></tr></tbody></table>
<h3 class="text-xl font-semibold mt-6 mb-3 text-ck-purple-light">Key Dimension Calculation</h3>

<p class="mb-4 text-gray-300">All thresholds use actual device pixels computed at runtime:</p>

<pre class="bg-ck-dark p-4 rounded-lg overflow-x-auto"><code class="language-kotlin">// Keyboard2View.kt
override fun getKeyHypotenuse(key: KeyboardData.Key): Float {
    val tc = themeComputed ?: return 0f

    // Find row height from layout
    var normalizedRowHeight = 0f
    for (row in keyboard.rows) {
        for (k in row.keys) {
            if (k == key) {
                normalizedRowHeight = row.height
                break
            }
        }
    }

    // Convert to actual pixels
    val keyHeightPx = normalizedRowHeight * tc.row_height
    val keyWidthPx = key.width * keyWidth

    return sqrt(keyWidthPx.pow(2) + keyHeightPx.pow(2))  // Diagonal in pixels
}</code></pre>

<h3 class="text-xl font-semibold mt-6 mb-3 text-ck-purple-light">Short Swipe Direction Detection</h3>

<p class="mb-4 text-gray-300">Direction calculated from delta between start and end positions:</p>

<pre class="bg-ck-dark p-4 rounded-lg overflow-x-auto"><code class="language-kotlin">private fun calculateSwipeDirection(dx: Float, dy: Float): SwipeDirection {
    val angle = atan2(-dy.toDouble(), dx.toDouble())  // Negative Y because screen coords
    val degrees = Math.toDegrees(angle)

    return when {
        degrees in -22.5..22.5 -&gt; SwipeDirection.E
        degrees in 22.5..67.5 -&gt; SwipeDirection.NE
        degrees in 67.5..112.5 -&gt; SwipeDirection.N
        degrees in 112.5..157.5 -&gt; SwipeDirection.NW
        degrees &gt; 157.5 || degrees &lt; -157.5 -&gt; SwipeDirection.W
        degrees in -157.5..-112.5 -&gt; SwipeDirection.SW
        degrees in -112.5..-67.5 -&gt; SwipeDirection.S
        degrees in -67.5..-22.5 -&gt; SwipeDirection.SE
        else -&gt; SwipeDirection.E
    }
}</code></pre>

<h3 class="text-xl font-semibold mt-6 mb-3 text-ck-purple-light">Circle Gesture Detection</h3>

<p class="mb-4 text-gray-300">Circle gestures detected via rotation accumulation:</p>

<pre class="bg-ck-dark p-4 rounded-lg overflow-x-auto"><code class="language-kotlin">class Gesture {
    private var totalRotation: Float = 0f
    private var lastAngle: Float = 0f

    fun addPoint(x: Float, y: Float, centerX: Float, centerY: Float) {
        val currentAngle = atan2(y - centerY, x - centerX)
        val delta = normalizeAngle(currentAngle - lastAngle)
        totalRotation += delta
        lastAngle = currentAngle
    }

    fun isCircleComplete(): Boolean {
        return abs(totalRotation) &gt;= 2 * PI  // Full circle (360 degrees)
    }

    fun getDirection(): CircleDirection {
        return if (totalRotation &gt; 0) CircleDirection.CLOCKWISE
               else CircleDirection.COUNTER_CLOCKWISE
    }
}</code></pre>

<h3 class="text-xl font-semibold mt-6 mb-3 text-ck-purple-light">Swipe Typing Activation</h3>

<p class="mb-4 text-gray-300">Long swipes trigger neural prediction when finger leaves starting key:</p>

<pre class="bg-ck-dark p-4 rounded-lg overflow-x-auto"><code class="language-kotlin">private fun onTouchUp(ptr: Pointer) {
    val gestureType = gestureClassifier.classify(GestureData(
        hasLeftStartingKey = ptr.hasLeftStartingKey,
        totalDistance = ptr.totalDistance,
        timeElapsed = ptr.timeElapsed,
        keyWidth = getKeyWidth(ptr.key)
    ))

    when (gestureType) {
        GestureType.SWIPE -&gt; {
            if (ptr.hasLeftStartingKey) {
                // Long swipe - neural prediction
                onSwipeEnd(ptr.swipePath)
            } else {
                // Short swipe - sublabel action
                val direction = calculateSwipeDirection(ptr.dx, ptr.dy)
                handleShortGesture(ptr, direction)
            }
        }
        GestureType.TAP -&gt; {
            handleTap(ptr.key)
        }
    }
}</code></pre>

<h3 class="text-xl font-semibold mt-6 mb-3 text-ck-purple-light">Pointer State</h3>

<pre class="bg-ck-dark p-4 rounded-lg overflow-x-auto"><code class="language-kotlin">data class Pointer(
    var key: KeyboardData.Key?,       // Starting key
    var downX: Float,                  // Initial touch X
    var downY: Float,                  // Initial touch Y
    var currentX: Float,               // Current X
    var currentY: Float,               // Current Y
    var downTime: Long,                // Touch start time
    var hasLeftStartingKey: Boolean,   // The gatekeeper flag
    var swipePath: MutableList&lt;Point&gt;, // Path for neural prediction
    var flags: Int                     // State flags (trackpoint, selection-delete, etc.)
)</code></pre>

        </div>
    </main>

    <!-- Footer -->
    <footer class="container mx-auto px-6 py-8 text-center text-gray-500 text-sm border-t border-gray-800">
        <p>CleverKeys Documentation - Generated from specs</p>
    </footer>
</body>
</html>